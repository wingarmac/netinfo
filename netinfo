#!/bin/bash
echo
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    cat <<EOF
Usage: netinfo [option]

Network reporting tool for Linux systems
Displays IP configuration, routing, DNS, firewall rules, and open TCP services.

Options:
  txt           Export the report to a local text file (netinfo-YYYY-MM-DD_HHhMM.txt)
  nc            Share the report via a public link using termbin.com (requires netcat-openbsd)
  --no-color    Disable ANSI color codes in terminal output
  --help        Show this help message and exit

Notes:
  - This tool uses 'ip', 'journalctl', and either 'nft' or 'iptables' depending on your firewall.
  - Sections involving firewall and open TCP ports require root privileges.
  - 'nmap' and 'lsof' are used to correlate open TCP ports with running services.

Examples:
  netinfo                 Run and display the report in the terminal
  netinfo txt             Export to text file
  netinfo nc              Share via termbin.com
  netinfo --no-color      Useful for piping or cron jobs

Version: 1.0  
License: GNU GPL v3.0  
Repository: https://github.com/wingarmac/netinfo
EOF
echo
    exit 0
fi

generate_report() {
    echo "===================================================="
    echo "          Outil d'information réseau (netinfo)      "
    echo "===================================================="
    echo ""

    # Detection materiel
    echo -e "\e[36mCartes réseau détectées (interface ↔ matériel)\e[0m"
    echo -e "\e[36m--------------------------------------------\e[0m"
    echo ""

    for iface in $(ls /sys/class/net/ | grep -v lo); do
        dev_path=$(readlink -f "/sys/class/net/$iface/device")
        if [[ -e "$dev_path" ]]; then
            pci_id=$(basename "$dev_path")              # ex: 0000:05:00.0
            short_id=${pci_id#0000:}                    # ex: 05:00.0
            lspci_line=$(lspci -nn | grep "^$short_id ")
            if [[ -n "$lspci_line" ]]; then
                echo "$iface ↔ $lspci_line"
            else
                echo "$iface ↔ (carte PCI non listée)"
            fi
        else
            echo "$iface ↔ (non liée à un bus PCI)"
        fi
    done

    echo ""

    echo -e "\e[32mAdresses IP des interfaces réseau\e[0m"
    echo -e "\e[32m---------------------------------\e[0m"
    echo ""
    ip a
    echo ""
    
    echo -e "\e[35mRoutes IPv4\e[0m"
    echo -e "\e[35m-----------\e[0m"
    ip route show
    echo ""

    echo -e "\e[35mRoutes IPv6\e[0m"
    echo -e "\e[35m-----------\e[0m"
    ip -6 route show
    echo ""

    echo -e "\e[94mServeurs DNS configurés\e[0m"
    echo -e "\e[94m------------------------\e[0m"
    echo ""
    start_line=$(journalctl -u systemd-resolved --no-pager | grep "Started systemd-resolved.service" | tail -n 1)

    if [ -n "$start_line" ]; then
        start_time=$(echo "$start_line" | awk '{print $1" "$2" "$3}')
        journalctl -u systemd-resolved --since "$start_time" --no-pager | sed -n "/Started systemd-resolved/,/search domain list/p"
    else
        echo "Impossible de trouver la ligne de démarrage du service systemd-resolved."
    fi

    echo ""
    echo -e "\e[31mStatut du pare-feu\e[0m"
    echo -e "\e[31m------------------\e[0m"
    echo ""

    if command -v nft &> /dev/null; then
        echo "Votre système utilise nftables."
        echo ""
        echo "Voici les règles :"
        echo ""

        full_ruleset=$(sudo nft list ruleset 2>/dev/null | grep -vE '^\s*#')

        afficher_table() {
            local table_label=$1
            local table_name=$2

            echo -e "\e[31mPare-feu $table_label\e[0m"
            echo -e "\e[31m------------------\e[0m"
            echo ""

            in_table=0
            current_chain=""
            while IFS= read -r line; do
                if [[ "$line" =~ ^table[[:space:]]+$table_name[[:space:]]+filter[[:space:]]*\{ ]]; then
                    in_table=1
                    continue
                fi

                if [[ $in_table -eq 1 ]]; then
                    if [[ "$line" == "}" ]]; then
                        in_table=0
                        continue
                    fi
                    if [[ "$line" =~ chain[[:space:]]+([A-Z]+)[[:space:]]*\{ ]]; then
                        current_chain="${BASH_REMATCH[1]}"
                        echo "● Chaîne : $current_chain"
                        continue
                    fi
                    [[ "$line" == *"}"* ]] && continue
                    [[ -n "$line" ]] && echo "    $line"
                fi
            done <<< "$full_ruleset"

            echo ""
        }

        afficher_table "IPv4" "ip"
        afficher_table "IPv6" "ip6"
    else
        echo "Votre système utilise iptables. Voici les règles :"
        echo ""
        echo -e "\e[31mPare-feu IPv4\e[0m"
        sudo iptables -L -n -v
        echo ""
        echo -e "\e[31mPare-feu IPv6\e[0m"
        sudo ip6tables -L -n -v
    fi

    echo -e "\e[33mPorts TCP ouverts et services associés\e[0m"
    echo -e "\e[33m--------------------------------------\e[0m"
    echo ""

    nmap_output=$(nmap -Pn localhost 2>/dev/null)
    tcp_ports=$(echo "$nmap_output" | awk '/^[0-9]+\/tcp/ {split($1,p,"/"); print p[1] " " $3}')

    if [ -z "$tcp_ports" ]; then
        echo "Aucun port TCP ouvert détecté par Nmap."
    else
        while read -r port service; do
            echo -e "\e[31mPort $port ($service)\e[0m"
            sudo lsof -nP -iTCP:$port -sTCP:LISTEN 2>/dev/null || echo "   Aucun processus en écoute sur ce port."
            echo ""
        done <<< "$tcp_ports"
    fi


    echo "===================================================="
    echo "              Fin du rapport netinfo                "
    echo "===================================================="


    if [[ -t 1 ]]; then
        echo ""
        echo -e "\e[93mSouhaitez-vous exporter ce rapport ?\e[0m"
        echo -e " - Pour un fichier texte local : \e[1mnetinfo txt\e[0m"
        echo -e " - Pour un lien partageable :     \e[1mnetinfo nc\e[0m"
    fi

}

# === Mode export texte / nc ===
if [[ "$1" == "nc" || "$1" == "txt" ]]; then
    tmp_file="/tmp/netinfo-raw-$$.log"
    generate_report > "$tmp_file"

    # Nettoyage des couleurs ANSI
    sed -i 's/\x1B\[[0-9;]*[JKmsu]//g' "$tmp_file"

    if [[ "$1" == "nc" ]]; then
        # Vérifie si netcat est installé
        REQUIRED_PKG="netcat-openbsd"
        PKG_OK=$(dpkg-query -W --showformat='${Status}\n' "$REQUIRED_PKG" 2>/dev/null | grep "install ok installed")
        if [ -z "$PKG_OK" ]; then
            echo "⏳ Le paquet '$REQUIRED_PKG' est requis. Installation en cours..."
            sudo apt update && sudo apt install -y "$REQUIRED_PKG"
            echo "✅ '$REQUIRED_PKG' installé."
        fi
        cat "$tmp_file" | nc termbin.com 9999 | tr -d '\0'
    else
        filename="netinfo-$(date '+%F_%Hh%M').txt"
        mv "$tmp_file" "$filename"
        echo "$PWD/$filename"
    fi
    exit 0
fi

# === Mode standard ===
generate_report
